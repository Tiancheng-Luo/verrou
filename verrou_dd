#!/bin/sh
''''exec python3 -u "$0" "$@" #'''
# This hack is an ugly but portable alternative to #!/usr/bin/env -S python3 -u

import subprocess
import sys
import os
import shutil
#import md5
import hashlib
import copy
from valgrind import DD
import traceback
import shutil
import signal

def failure():
    sys.exit(42)

nbRUN=5
try:
    nbRUN = int(os.environ["VERROU_DD_NRUNS"])
except:
    pass

maxNbPROC=None
try:
    maxNbPROC = int(os.environ["VERROU_DD_NUM_THREADS"])
except:
    pass

ddAlgo="ddmax"
try:
    algo = os.environ["VERROU_DD_ALGO"]
    if algo in ["ddmax","rddmin"]:
        ddAlgo=algo
    else:
        print("incorrect VERROU_DD_ALGO env variable")
        failure()
except:
    pass


ddIgnoreLine=False
try:
    ddIgnoreLine = os.environ["VERROU_DD_IGNORE_LINE"]
    ddIgnoreLine=True
except:
    pass




def runCmdAsync(cmd, fname, envvars=None):
    """Run CMD, adding ENVVARS to the current environment, and redirecting standard
    and error outputs to FNAME.out and FNAME.err respectively.

    Returns CMD's exit code."""
    if envvars is None:
        envvars = {}

    with open("%s.out"%fname, "w") as fout:
        with open("%s.err"%fname, "w") as ferr:
            env = copy.deepcopy(os.environ)
            for var in envvars:
                env[var] = envvars[var]
            return subprocess.Popen(cmd, env=env, stdout=fout, stderr=ferr)

def getResult(subProcess):
    subProcess.wait()
    return subProcess.returncode


def runCmd(cmd, fname, envvars=None):
    """Run CMD, adding ENVVARS to the current environment, and redirecting standard
    and error outputs to FNAME.out and FNAME.err respectively.

    Returns CMD's exit code."""

    return getResult(runCmdAsync(cmd,fname,envvars))



class verrouTask:

    def __init__(self, prefix,deltas, refDir,runCmd, cmpCmd,nbRun, typeRun="exclude"):
        self.dirname=os.path.join(prefix, md5Name(deltas))
        self.refDir=refDir
        self.runCmd=runCmd
        self.cmpCmd=cmpCmd
        self.nbRun=nbRun
        self.FAIL=DD.DD.FAIL
        self.PASS=DD.DD.PASS
        self.typeRun=typeRun
        self.subProcessRun={}
        
        if not os.path.exists(self.dirname):
            os.makedirs(self.dirname)
            if self.typeRun=="exclude":
                genExcludeFile(self.refDir, self.dirname, deltas)
            if self.typeRun=="source":
        
                with open(os.path.join(self.dirname,"dd.source"), "w") as f:
                    f.write("__unknown__\t0\n")
                    for d in deltas:
                        f.write(d)
        print(self.dirname,end="")
        
    def nameDir(self,i):
        return  os.path.join(self.dirname,"dd.run%i" % (i+1))

    def mkdir(self,i):
         os.mkdir(self.nameDir(i))
    def rmdir(self,i):
        shutil.rmtree(self.nameDir(i))

    def runOneSample(self,i):
        rundir= self.nameDir(i)
        env={}
        if self.typeRun=="exclude":
            env={"VERROU_EXCLUDE": os.path.join(self.dirname,"dd.exclude")}
        if self.typeRun=="source":
            env={"VERROU_SOURCE":  os.path.join(self.dirname,"dd.source")}

        self.subProcessRun[i]=runCmdAsync([self.runCmd, rundir],
                                          os.path.join(rundir,"dd.run"),
                                          env)

    def cmpOneSample(self,i):
        rundir= self.nameDir(i)
        if self.subProcessRun[i]!=None:
            getResult(self.subProcessRun[i])
        retval = runCmd([self.cmpCmd, self.refDir, rundir],
                        os.path.join(rundir,"dd.compare"))

        with open(os.path.join(self.dirname, rundir, "returnVal"),"w") as f:
            f.write(str(retval))
        if retval != 0:
            print("FAIL(%d)" % i)
            return self.FAIL
        else:
            return self.PASS

    def sampleToComputeToGetFailure(self, nbRun):
        """Return the list of samples which have to be computed to perforn nbRun Success run : None mean Failure [] Mean Success """
        listOfDir=[runDir for runDir in os.listdir(self.dirname) if runDir.startswith("dd.run")]
        done=[]
        for runDir in listOfDir:
            status=int((open(os.path.join(self.dirname, runDir, "returnVal")).readline()))
            if status!=0:
                return None
            done+=[runDir]

        res= [x for x in range(nbRun) if not ('dd.run'+str(x+1)) in done]
        return res
        
    def run(self):
        workToDo=self.sampleToComputeToGetFailure(self.nbRun)
        if workToDo==None:
            print("--(cache) -> FAIL")
            return self.FAIL
        
        if len(workToDo)!=0:
            print(" --( run )-> ",end="",flush=True)        
        
            if maxNbPROC==None:
                returnVal=self.runSeq(workToDo)
            else:
                returnVal=self.runPar(workToDo)

            if(returnVal==self.PASS):
                print("PASS(+" + str(len(workToDo))+"->"+str(self.nbRun)+")" )
            return returnVal
        print(" --(cache)-> PASS("+str(self.nbRun)+")")
        return self.PASS
    

    def runSeq(self,workToDo):

        for run in workToDo:
            self.mkdir(run)
            self.runOneSample(run)
            retVal=self.cmpOneSample(run)
            
            if retVal=="FAIL":
                return self.FAIL
        return self.PASS

    def runPar(self,workToDo):            

        for run in workToDo:
            self.mkdir(run)
            self.runOneSample(run)
        for run in workToDo:
            retVal=self.cmpOneSample(run)
            
            if retVal=="FAIL":
                return self.FAIL

        return self.PASS


def md5Name(deltas):
    copyDeltas=copy.copy(deltas)
    copyDeltas.sort()
    return hashlib.md5(("".join(copyDeltas)).encode('utf-8')).hexdigest()


def prepareOutput(dirname):
     shutil.rmtree(dirname, ignore_errors=True)
     os.makedirs(dirname)

def genExcludeFile(ref, dest, include):
    """Generate the dd.exclude and dd.include file in rep dest from the dd.exclude (coming from ref) and include tab (usually called deltas)"""
    with open(os.path.join(ref,"dd.exclude"), "r") as f:
        excludes = f.readlines()
    with open(os.path.join(dest,"dd.include"), "w") as f:
        for d in include:
            excludes.remove(d)
            f.write(d)
    with open(os.path.join(dest,"dd.exclude"), "w") as f:
        for line in excludes:
            f.write(line)
            
def mergeList(dirname, name="dd.exclude"):
    """merge the file name.$PID into a uniq file called name """ 
    listOfExcludeFile=[ x for x in os.listdir(dirname) if x.startswith(name+".")]
    if len(listOfExcludeFile)<1:
        print("The generation of exclusion/source files failed")
        failure()
                
    with open(os.path.join(dirname,listOfExcludeFile[0]), "r") as f:
        excludeMerged=f.readlines()

    for excludeFile in listOfExcludeFile[1:]:
        with open(os.path.join(dirname,excludeFile), "r") as f:
            for line in f.readlines():
                if line not in excludeMerged:
                    excludeMerged+=[line]
    with open(os.path.join(dirname, name), "w" )as f:
        for line in excludeMerged:
            f.write(line)


def symlink(src, dst):
    if os.path.exists(dst):
        os.remove(dst)
    os.symlink(src, dst)


class DDvr(DD.DD):
    def __init__(self, prefix):
        DD.DD.__init__(self)
        self.cache_outcomes = False
        self.prefix_ = os.path.join(os.getcwd(),prefix)
        self.ref_ = os.path.join(self.prefix_, "ref")
        self.index=0

    def RDDMin(self, deltas,nbRun=nbRUN):
        ddminTab=[]
        testResult=self._test(deltas)
        if testResult!=self.FAIL:
            self.deltaFailedMsg(deltas)

        while testResult==self.FAIL:
#            conf = self.ddmin(deltas)
            conf = self.verrou_dd_min(deltas,nbRun)

            ddminTab += [conf]
            print("ddmin%d (%s):"%(self.index,self.coerce(conf)))

            #update deltas
            deltas=[delta for delta in deltas if delta not in conf]
            testResult=self._test(deltas,nbRun)
            self.index+=1
        return ddminTab


    def splitDeltas(self, deltas,nbRun=nbRUN, granularity=2):
        res=[]
        toTreat=[deltas]

        while len(toTreat)!=0:
            cutCandidat=toTreat[0]
            toTreat=toTreat[1:]
            ciTab=self.split(cutCandidat, min(granularity, len(cutCandidat)))

            cutAbleStatus=False
            for ci in ciTab:
                status=self._test(ci ,nbRun)
                if status==self.FAIL:
                    if len(ci)==1:
                        print("ddmin%d (%s):"%(self.index,self.coerce(ci)))
                        self.index+=1
                        res+=[ci]
                    else:
                        toTreat=[ci]+toTreat
                    cutAbleStatus=True

            if cutAbleStatus==False:
                res+=[cutCandidat]
        return res

    def DRDDMin(self, deltas, nbRun=nbRUN, nbRunMin=1, nbRunInc=lambda x: x+1,granularity=2):

        testResult=self._test(deltas,nbRun)
        if testResult!=self.FAIL:
            self.deltaFailedMsg(deltas)


        candidats=self.splitDeltas(deltas,nbRun, granularity)
        print("Dicotomy split done")
        res=[]
        for candidat in candidats:
            if len(candidat)==1:
                res+=[candidat]
                deltas=[delta for delta in deltas if delta not in candidat]
            else:
                resTab=self.RDDMin(candidat,nbRun)
                for resMin in resTab:
                    res+=[resMin]
                    deltas=[delta for delta in deltas if delta not in resMin]
        print("Dicotomy split analyze done")

        testResult=self._test(deltas,nbRun)
        if testResult!=self.FAIL:
            return res
        else:
            return res+self.SRDDMin(deltas,nbRun,nbRunMin, nbRunInc)



    def SRDDMin(self, deltas,nbRun=nbRUN, nbRunMin=1, nbRunInc=lambda x: x+1):
        ddminTab=[]
        testResult=self._test(deltas,nbRun)
        if testResult!=self.FAIL:
            self.deltaFailedMsg(deltas)


        run=min(nbRun,nbRunMin)
        
        while run <= nbRun:
            testResult=self._test(deltas,run)
           
            while testResult==self.FAIL:

            #            conf = self.ddmin(deltas)
                conf = self.verrou_dd_min(deltas,run)
                if len(conf)!=1:                    
                    runIncValue=min(nbRun,nbRunInc(run))
                    while runIncValue<=nbRun:
                        conf = self.verrou_dd_min(conf,runIncValue)            
                        if len(conf)==1:
                            break
                        else:
                            runIncValue=max(runIncValue+1,min(nbRun,nbRunInc(runIncValue)))
                    
                ddminTab += [conf]
                print("ddmin%d (%s):"%(self.index,self.coerce(conf)))
                self.index+=1

                deltas=[delta for delta in deltas if delta not in conf]
                testResult=self._test(deltas,nbRun)


            run=max(run+1,min(nbRun, nbRunInc(run)))
        return ddminTab


class DDsym(DDvr):
    def __init__(self, run, compare):
        DDvr.__init__(self, "dd.sym")
        self.run_ = run
        self.compare_ = compare

        self.reference()
        mergeList(self.ref_,"dd.exclude")
        self.checkReference()

    def reference(self):
        dirname = self.ref_
        prepareOutput(dirname)

        retval = runCmd([self.run_, dirname],
                        os.path.join(dirname,"dd"),
                        {"VERROU_ROUNDING_MODE": "nearest",
                         "VERROU_GEN_EXCLUDE":   os.path.join(dirname,"dd.exclude.%%p")})
        assert retval == 0, "Error during reference run"


    def checkReference(self):
        retval = runCmd([self.compare_,self.ref_, self.ref_],
                        os.path.join(self.ref_,"checkRef"))
        if retval != 0:
            print("FAILURE: the reference is not valid ")
            print("Suggestions:")
            print("\t1) check the correctness of the %s script"%self.compare_)
            print("\t2) if your code contains C++ code (libraries included), check the presence of the valgrind option --demangle=no in the run script")

            print("Files to analyze:")
            print("\t run output: " +  os.path.join(self.ref_,"dd.out") + " " + os.path.join(self.ref_,"dd.err"))
            print("\t cmp output: " +  os.path.join(self.ref_,"checkRef.out") + " "+ os.path.join(self.ref_,"checkRef.err"))
            failure()
#            print("\t3) check the ")

    def deltaFailedMsg(self,delta):
        print("FAILURE: nothing to debug (the run with all symbols activated succeed)")
        print("Suggestions:")
        print("\t1) check the correctness of the %s script : the failure criteria may be too large"%self.compare_)
        print("\t2) check if the number of samples VERROU_DD_NRUNS is sufficient ")
        print("\t3) if your code contains C++ code (libraries included), check the presence of the valgrind option --demangle=no in the run script")

        dirname = md5Name(delta)
        print("Directory to analyze: %s"%dirname)
        failure()

    def allDeltaFailedMsg(self,deltas):
        print ("FAILURE: when verrou perturbs all parts of the program, its output is still detected as stable.")
        print ("Suggestions:")
        print ("\t1) check if the number of samples VERROU_DD_NRUNS is sufficient")
        print ("\t2) check the correctness of the %s script : the failure criteria may be too large"%self.compare_)
        print ("\t3) set the env variable VERROU_DD_UNSAFE : be careful it is realy unsafe")

        failure()

        

    def noDeltaSucceedMsg(self,deltas=[]):
        print("FAILURE: the comparison between verrou with activated symbols in nearest mode (ref) and verrou without activated symbols failed")
        
        print("Suggestions:")
        print("\t1) check the libm library is correctly excluded")
        print("\t2) check if reproducibilty discrepancies are larger than the failure criteria of the script %s"%self.compare_)
        failure()

    def _test(self, deltas,nbRun=nbRUN):

        vT=verrouTask(self.prefix_,deltas, self.ref_,self.run_, self.compare_ ,nbRun, "exclude")
        return vT.run()


    
    def coerce(self, config):
        return "\n  " + "  ".join(config)

    def testSym(self, deltas, symlinkconf=None):
        #by default the symlinks are generated when the test fail

        testResult=self._test(deltas)

        syms = [delta.partition("\t")[0] for delta in deltas]
        #symsname=reduce(lambda sym1,sym2 : sym1+","+sym2,syms)
        symsname=",".join(syms)

        if symlinkconf==True or (symlinkconf!=False and testResult==self.FAIL):
            if symlinkconf==None:
                linkname = "%s.%s"%(self.prefix_, symsname)
            else:
                linkname=  os.path.join(self.prefix_,symlinkconf)
            dirname = os.path.join(self.prefix_, md5Name(deltas))
            symlink(dirname, linkname)

        if testResult==self.PASS:
            print("WARNING: the symbol(s) " + symsname + "do not generate a FAIL")

        return testResult

def ddSym(run, compare):
    dd = DDsym(run, compare)

    with open(os.path.join(dd.ref_,"dd.exclude"), "r") as f:
        deltas = f.readlines()

#    conf = dd.ddmax(deltas)
    conf = dd.verrou_dd_max(deltas)
    print("ddmax:" + dd.coerce(conf))

    #for delta in conf:
    #    dd.testSym(delta)
    reducedConf=[delta for delta in conf if dd.testSym([delta])==dd.FAIL]

    return (dd.ref_, [reducedConf])

def ddSymRDDMin(run, compare):
    dd = DDsym(run,compare)
    with open(os.path.join(dd.ref_,"dd.exclude"), "r") as f:
        deltas = f.readlines()
    confTab = dd.DRDDMin(deltas)

    for i in range(len(confTab)):
        conf=confTab[i]
        dd.testSym(conf, symlinkconf="ddmin-%d"%(i))

    return (dd.ref_, confTab)

class DDline(DDvr):
    def __init__(self, run, compare, refSym, confSyms, prefix="dd.line"):
        DDvr.__init__(self, prefix)
        self.run_ = run
        self.compare_ = compare

        prepareOutput(self.ref_)
        genExcludeFile(refSym, self.ref_, confSyms)
        self.reference()
        mergeList(self.ref_,"dd.source")

    def reference(self):
        dirname = self.ref_
        retval = runCmd([self.run_, dirname],
                        os.path.join(dirname,"dd"),
                        {"VERROU_ROUNDING_MODE": "nearest",
                         "VERROU_EXCLUDE":       os.path.join(dirname,"dd.exclude"),
                         "VERROU_GEN_SOURCE":    os.path.join(dirname,"dd.source.%%p")})
        assert retval == 0, "Error during ddline reference run"

    def filterSourceRef(self, confSyms):
        """Filter dd.source ref by removing the line coming from the symbols (confSyms)"""
        deltas = []
        for sym in confSyms:
            symname = sym.partition("\t")[0]
            with open(os.path.join(self.ref_ ,"dd.source"), "r") as f:
                for line in f:
                    if line.endswith("\t%s\n"%symname) and line not in deltas:
                        deltas.append(line)
        return deltas


    def _test(self, deltas,nbRun=nbRUN):
        vT=verrouTask(self.prefix_, deltas, self.ref_,self.run_, self.compare_ ,nbRun, "source")
        return vT.run()

    def coerce(self, config):
        return  "\n  " + "\n  ".join(["%s:%d (%s)" % e for e in
                                      [(col[0], int(col[1]), col[2]) for col in
                                       [(l.strip()+"\t\t").split("\t") for l in config]]])

    def testLine(self, delta, symlinkconf=None):
        deltas = [delta]
#        dirname = self.testName(deltas)
        testResult=self._test(deltas)

        (filename, linenum) = delta.strip().split("\t")[0:2]
        if symlinkconf==True or (symlinkconf==None and testResult==self.FAIL):
            linkname = "%s.%s:%s"%(self.prefix_, filename, linenum)
            dirname=os.path.join(self.prefix_,md5Name(deltas))
            symlink(dirname, linkname)
        if testResult==self.PASS:
            print("WARNING: the line %s:%s do not generate a FAIL"%(filename,linenum))


    def testLines(self, deltas, symlinkconf=None):
#        dirname = self.testName(deltas)
        testResult=self._test(deltas)

        #get the name of the conf
        dictLines={}
        for (filename, linenum) in [delta.strip().split("\t")[0:2] for delta in deltas]:
            if filename in dictLines:
                dictLines[filename]+=[linenum]
            else:
                dictLines[filename]=[linenum]
        confname="_".join([f+":"+ (",".join(dictLines[f]))  for f in dictLines] )
#        confname="_".join([f+":"+reduce(lambda l1,l2: l1+","+l2 ,dictLines[f])  for f in dictLines] )
        
        
        if symlinkconf==True or (symlinkconf==None and testResult==self.FAIL):
            linkname = "%s.%s"%(self.prefix_, confname)
            dirname=os.path.join(self.prefix_,md5Name(deltas))
            symlink(dirname, linkname)
        if testResult==self.PASS:
            print("WARNING: the line %s do not generate a FAIL"%(confname))


    def noDeltaSucceedMsg(self,deltas=[]):
        raise DDLineError("noDeltaSucceedMsg")

    def deltaFailedMsg(self, deltas=[]):
        raise DDLineError("deltaFailedMsg")

    def allDeltaFailedMsg(self, deltas):
        raise DDLineError("allDeltaFailedMsg")



class DDLineError(Exception):
    """Exception for DDLine Algorithm"""
    def __init__(self,msg):
        self.msg=msg


def ddLine(run, compare, refSym, confSymsTab):
    confLines = []

    for confSyms in confSymsTab:
        dd = DDline(run, compare, refSym, confSyms)

        for confSym in confSyms:
            deltas=dd.filterSourceRef([confSym])
            try:
                conf = dd.verrou_dd_max(deltas)
                confLines += conf
                symname = ",".join([sym.partition("\t")[0] for sym in confSyms])
                print("ddmax (%s):"%symname + dd.coerce(conf))

                for delta in conf:
                    dd.testLine(delta)
            except DDLineError:
                traceback.print_exc()

    print("ddmax (global):" + dd.coerce(confLines))
    return confLines


def ddLineRDDMin(run, compare, refSym, confSymsTab):

    confLines = []
    for i in range(len(confSymsTab)):
        confSyms=confSymsTab[i]
        dd = DDline(run, compare, refSym, confSyms, os.path.join("dd.sym","ddmin-%d"%(i) ,"dd.line"))

        deltas=dd.filterSourceRef(confSyms)
        symname = ",".join([sym.partition("\t")[0] for sym in confSyms])

        if(len(deltas)==0):
            print("Warning ddLinerddMin(%s) : empty lines search (symbol compiled with debug option?)"%(symname))
            continue

        try:
            ddminTab=dd.DRDDMin(deltas)
        except DDLineError:
            ddminTab=[]
            traceback.print_exc()

        for ddmin in ddminTab:
            dd.testLines(ddmin)
        confLines+=ddmin


def main(run, compare,algoSearch="ddmax"):
    if algoSearch=="ddmax":
        (refSym, confSymsTab) = ddSym(run, compare)
        if not ddIgnoreLine:
            ddLine(run, compare, refSym, confSymsTab)
    if algoSearch=="rddmin":
        (refSym, confSymsTab) = ddSymRDDMin(run, compare)
        if not ddIgnoreLine:
            ddLineRDDMin(run, compare, refSym, confSymsTab)

def usageCmd():
    print("Usage: "+ sys.argv[0] + " runScript cmpScript")

def checkScriptPath(fpath):
    if os.path.isfile(fpath) and os.access(fpath, os.X_OK):
        return os.path.abspath(fpath)
    else:
        print("Invalid Cmd:"+str(sys.argv))
        print(fpath + " should be executable")
        usageCmd()
        failure()


if __name__ == "__main__":

    if len(sys.argv)!=3:
        usageCmd()
        failure()

    runScript=checkScriptPath(sys.argv[1])
    cmpScript=checkScriptPath(sys.argv[2])

    main(runScript, cmpScript, algoSearch=ddAlgo)

